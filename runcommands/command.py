import argparse
import inspect
import sys
import time
from collections import Mapping, OrderedDict
from types import MethodType

from .args import Arg, ArgConfig, HelpArg, BoolOrAction, DictAddAction, ListAppendAction
from .const import DEFAULT_ENV
from .exc import CommandError, RunCommandsError
from .util import Hide, cached_property, get_hr, printer


__all__ = ['command']


class Command:

    """Command.

    Wraps a callable and provides a command line argument parser.

    This is typically used via the ``command`` decorator::

        from runcommands import command

        @command
        def my_command(config):
            pass

    Args:
        implementation (callable): A callable that implements the
            command's functionality. The command's console script will
            be generated by inspecting this callable.
        name (str): Name of command as it will be called from the
            command line. Defaults to ``implementation.__name__`` (with
            underscores replaced with dashes).
        description (str): Description of command shown in command
            help. Defaults to ``implementation.__doc__``.
        env (str): Env to run command in. If this is specified, the
            command *will* be run in this env and may *only* be run in
            this env. If this is set to :const:`DEFAULT_ENV`, the
            command will be run in the configured default env.
        default_env (str): Default env to run command in. If this is
            specified, the command will be run in this env by default
            and may also be run in any other env. If this is set to
            :const:`DEFAULT_ENV`, the command will be run in the
            configured default env.
        config (dict): Additional or override config. This will
            supplement or override config read from other sources.
            Passed args take precedence over this config.
            ``{'dotted.name': value}``
        timed (bool): Whether the command should be timed. Will print an
            info message showing how long the command took to complete
            when ``True``. Defaults to ``False``.

    """

    def __init__(self, implementation, name=None, description=None, env=None, default_env=None,
                 config=None, timed=False):
        if env is not None and default_env is not None:
            raise CommandError('Only one of `env` or `default_env` may be specified')

        self.implementation = implementation
        self.name = name or self.normalize_name(implementation.__name__)
        self.description = description or self.get_description_from_docstring(implementation)
        self.env = env
        self.default_env = default_env
        self.config = config or {}
        self.timed = timed

        qualified_name = '{implementation.__module__}.{implementation.__qualname__}'
        qualified_name = qualified_name.format_map(locals())
        self.qualified_name = qualified_name
        self.defaults_path = 'defaults.{self.qualified_name}'.format_map(locals())
        self.short_defaults_path = 'defaults.{self.name}'.format_map(locals())

    @classmethod
    def command(cls, name=None, description=None, env=None, default_env=None,
                config=None, timed=False):
        args = dict(
            description=description,
            env=env,
            default_env=default_env,
            config=config,
            timed=timed,
        )

        if callable(name):
            # @command used as a bare decorator.
            return Command(implementation=name, **args)

        def wrapper(wrapped):
            return Command(implementation=wrapped, name=name, **args)

        return wrapper

    def get_description_from_docstring(self, implementation):
        description = implementation.__doc__
        if description is not None:
            description = description.strip() or None
        if description is not None:
            lines = description.splitlines()
            title = lines[0]
            if title.endswith('.'):
                title = title[:-1]
            lines = [title] + [line[4:] for line in lines[1:]]
            description = '\n'.join(lines)
        return description

    def get_run_env(self, specified_env, global_default_env):
        env = self.env
        default_env = self.default_env

        if env is not None:
            if env is DEFAULT_ENV:
                env = global_default_env

            if env is True:
                # The command has no default env and requires one to be
                # specified.
                if not specified_env:
                    raise CommandError(
                        'The `{self.name}` command requires an env to be specified'
                        .format_map(locals()))
                run_env = specified_env
            elif env is False:
                # The command explicitly doesn't run in an env.
                if specified_env:
                    raise CommandError(
                        'The `{self.name}` command may *not* be run in an env but '
                        'the "{specified_env}" env was specified'.format_map(locals()))
                run_env = None
            else:
                # The command may only be run in a designated env; make
                # sure the specified env matches that env.
                if specified_env and specified_env != env:
                    raise CommandError(
                        'The `{self.name}` command may be run only in the "{env}" env but '
                        'the "{specified_env}" env was specified'.format_map(locals()))
                run_env = env
        elif default_env is not None:
            if specified_env:
                # If an env was specified, the command will be run in that env.
                run_env = specified_env
            elif default_env is True or default_env is DEFAULT_ENV:
                # If no env was specified *and* the command indicates that it
                # should be run in the global default env, the command will be
                # run in the global default env.
                run_env = global_default_env
            else:
                # Otherwise, the command will be run in whatever default env
                # was indicated in the command definition.
                run_env = default_env
        else:
            # The command was configured without any env options, so use
            # the specified env (which may be None).
            run_env = specified_env

        return run_env

    def run(self, run_config, argv, **kwargs):
        if self.timed:
            start_time = time.monotonic()

        run_env = self.get_run_env(run_config.env, run_config.default_env)
        run_config = run_config.copy(env=run_env)

        config = Config(run=run_config, **self.config.copy())

        all_args = self.parse_args(config, argv)
        all_args.update(kwargs)
        result = self(config, **all_args)

        if self.timed:
            hide = kwargs.get('hide', config.run.hide)
            if not Hide.hide_stdout(hide):
                self.print_elapsed_time(time.monotonic() - start_time)

        return result

    def console_script(self, _argv=None, _run_args=None, **kwargs):
        from .run import read_run_args

        argv = sys.argv[1:] if _argv is None else _argv

        try:
            run_config = RunConfig(commands={self.name: self})
            run_config.update(read_run_args(self))
            run_config.update(_run_args or {})
            self.run(run_config, argv, **kwargs)
        except RunCommandsError as exc:
            printer.error(exc, file=sys.stderr)
            return 1

        return 0

    def __call__(self, config, *args, **kwargs):
        # Merge config from the command's definition along with options
        # specified on the command line. We already do this in the run()
        # method above, but we have to ensure it's done when the command
        # is called directly too.
        config = config.copy(self.config.copy())
        debug = config.run.debug
        commands = config.run.commands
        replacement = commands.get(self.name)
        replaced = replacement is not None and replacement is not self

        if replaced:
            if debug:
                printer.debug('Command replaced:', self.name)
                printer.debug('    ', self.qualified_name, '=>', replacement.qualified_name)
            return replacement(config, *args, **kwargs)

        if debug:
            printer.debug('Command called:', self.name)
            printer.debug('    Received positional args:', args)
            printer.debug('    Received keyword args:', kwargs)

        defaults = self.get_defaults(config)

        if defaults:
            nonexistent_defaults = [n for n in defaults if n not in self.args]
            if nonexistent_defaults:
                nonexistent_defaults = ', '.join(nonexistent_defaults)
                raise CommandError(
                    'Nonexistent default options specified for {self.name}: {nonexistent_defaults}'
                    .format_map(locals()))

            positionals = OrderedDict()
            for name, value in zip(self.positionals, args):
                positionals[name] = value

            for name in self.positionals:
                present = name in positionals or name in kwargs
                if not present and name in defaults:
                    kwargs[name] = defaults[name]

            for name in self.optionals:
                present = name in kwargs
                if not present and name in defaults:
                    kwargs[name] = defaults[name]

        def set_run_default(option):
            # If all of the following are true, the global default value
            # for the option will be injected into the options passed to
            # the command for this run:
            #
            # - This command defines the option.
            # - The option was not passed explicitly on this run.
            # - A global default is set for the option (it's not None).
            if option in self.args and option not in kwargs:
                global_default = config._get_dotted('run.%s' % option, None)
                if global_default is not None:
                    kwargs[option] = global_default

        set_run_default('echo')
        set_run_default('hide')

        if debug:
            printer.debug('Running command:', self.name)
            printer.debug('    Final positional args:', repr(args))
            printer.debug('    Final keyword args:', repr(kwargs))

        return self.implementation(config, *args, **kwargs)

    def get_defaults(self, config):
        defaults = config._get_dotted(self.defaults_path, RawConfig())
        defaults.update(config._get_dotted(self.short_defaults_path, RawConfig()))
        return defaults

    def get_default(self, config, name, default=None):
        defaults = self.get_defaults(config)
        return defaults.get(name, default)

    def parse_args(self, config, argv):
        debug = config.run.debug
        if debug:
            printer.debug('Parsing args for command `{self.name}`: {argv}'.format_map(locals()))

        parsed_args = self.get_arg_parser(config).parse_args(argv)
        parsed_args = vars(parsed_args)
        for k, v in parsed_args.items():
            if v == '':
                parsed_args[k] = None
        return parsed_args

    def normalize_name(self, name):
        # Chomp a single trailing underscore *if* the name ends with
        # just one trailing underscore. This accommodates the convention
        # of adding a trailing underscore to reserved/built-in names.
        if name.endswith('_'):
            if name[-2] != '_':
                name = name[:-1]

        name = name.replace('_', '-')
        name = name.lower()
        return name

    def get_arg_config(self, parameter):
        annotation = parameter.annotation
        if annotation is parameter.empty:
            annotation = self.arg_config.get(parameter.name) or ArgConfig()
        elif isinstance(annotation, type):
            annotation = ArgConfig(type=annotation)
        elif isinstance(annotation, str):
            annotation = ArgConfig(help=annotation)
        elif isinstance(annotation, Mapping):
            annotation = ArgConfig(**annotation)
        return annotation

    def get_short_option_for_arg(self, name, names, used):
        first_char = name[0]
        first_char_upper = first_char.upper()

        if first_char == 'e':
            # Ensure echo gets -E for consistency.
            if name == 'echo':
                candidates = ('E',)
            elif 'echo' not in names:
                candidates = (first_char, first_char_upper)
            else:
                candidates = (first_char,)
        elif first_char == 'h':
            # Ensure help gets -h and hide gets -H for consistency.
            if name == 'help':
                candidates = (first_char,)
            elif name == 'hide':
                candidates = (first_char_upper,)
            elif 'hide' not in names:
                candidates = (first_char_upper,)
            else:
                candidates = ()
        else:
            candidates = (first_char, first_char_upper)

        for char in candidates:
            short_option = '-{char}'.format_map(locals())
            if short_option not in used:
                return short_option

    def get_long_option_for_arg(self, name):
        return '--{name}'.format_map(locals())

    def get_inverse_option_for_arg(self, long_option):
        if long_option == '--yes':
            return '--no'
        if long_option == '--no':
            return '--yes'
        return long_option.replace('--', '--no-', 1)

    def print_elapsed_time(self, elapsed_time):
        m, s = divmod(elapsed_time, 60)
        m = int(m)
        hr = get_hr()
        msg = '{hr}\nElapsed time for {self.name} command: {m:d}m {s:.3f}s\n{hr}'
        msg = msg.format_map(locals())
        printer.info(msg)

    @cached_property
    def args(self):
        """Create args from function parameters."""
        implementation = self.implementation
        signature = inspect.signature(implementation)
        parameters = tuple(signature.parameters.items())[1:]
        parameters = OrderedDict(parameters)

        args = OrderedDict()

        # This will be overridden if the command explicitly defines an
        # arg named help.
        args['help'] = HelpArg(command=self)

        normalize_name = self.normalize_name
        get_arg_config = self.get_arg_config
        get_short_option = self.get_short_option_for_arg
        get_long_option = self.get_long_option_for_arg
        get_inverse_option = self.get_inverse_option_for_arg

        names = {normalize_name(name) for name in parameters}

        used_short_options = set()
        for parameter in parameters.values():
            annotation = get_arg_config(parameter)
            short_option = annotation.short_option
            if short_option:
                used_short_options.add(short_option)

        for name, parameter in parameters.items():
            name = normalize_name(name)

            if name.startswith('_') or parameter.kind is parameter.KEYWORD_ONLY:
                continue

            annotation = get_arg_config(parameter)
            type = annotation.type
            choices = annotation.type
            help = annotation.type
            short_option = annotation.type

            if parameter.default is parameter.empty:  # Positional
                short_option = None
                long_option = None
                inverse_option = None
            else:
                if not short_option:
                    short_option = get_short_option(name, names, used_short_options)
                    used_short_options.add(short_option)
                long_option = get_long_option(name)
                inverse_option = get_inverse_option(long_option)

            args[name] = Arg(
                command=self,
                parameter=parameter,
                name=name,
                type=type,
                default=parameter.default,
                choices=choices,
                help=help,
                short_option=short_option,
                long_option=long_option,
                inverse_option=inverse_option,
            )

        option_map = OrderedDict()
        for arg in args.values():
            for option in arg.options:
                option_map.setdefault(option, [])
                option_map[option].append(arg)

        for option, option_args in option_map.items():
            if len(option_args) > 1:
                names = ', '.join(a.parameter.name for a in option_args)
                message = (
                    'Option {option} of command {self.qualified_name} maps to multiple '
                    'parameters: {names}')
                message = message.format_map(locals())
                raise CommandError(message)

        return args

    @cached_property
    def positionals(self):
        args = self.args.items()
        return OrderedDict((name, arg) for (name, arg) in args if arg.is_positional)

    @cached_property
    def optionals(self):
        args = self.args.items()
        return OrderedDict((name, arg) for (name, arg) in args if arg.is_optional)

    @cached_property
    def option_map(self):
        """Map command-line options to args."""
        option_map = OrderedDict()
        for arg in self.args.values():
            for option in arg.options:
                option_map[option] = arg
        return option_map

    def get_arg_parser(self, config=None):
        if config is None:
            config = Config()

        use_default_help = isinstance(self.args['help'], HelpArg)

        parser = argparse.ArgumentParser(
            prog=self.name,
            description=self.description,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            argument_default=argparse.SUPPRESS,
            add_help=use_default_help,
            allow_abbrev=False,
        )

        defaults = self.get_defaults(config)

        for name, arg in self.args.items():
            if name == 'help' and use_default_help:
                continue

            if arg.is_positional and name in defaults:
                default = defaults[name]
            else:
                default = arg.default

            kwargs = {
                'help': arg.help,
            }

            metavar = name.upper().replace('-', '_')
            if (arg.is_dict or arg.is_list) and len(name) > 1 and name.endswith('s'):
                metavar = metavar[:-1]

            if arg.is_positional:
                kwargs['type'] = arg.type
                if arg.choices is not None:
                    kwargs['choices'] = arg.choices
                # Make positionals optional if a default value is
                # specified via config.
                if default is not arg.empty:
                    kwargs['nargs'] = '?'
                    kwargs['default'] = default
                kwargs['metavar'] = metavar
                parser.add_argument(arg.parameter.name, **kwargs)
            else:
                options = arg.options
                kwargs['dest'] = arg.parameter.name

                if arg.is_bool_or:
                    # Allow --xyz or --xyz=<value>
                    other_type = arg.type.type
                    true_or_value_kwargs = kwargs.copy()
                    true_or_value_kwargs['type'] = other_type
                    if arg.choices is not None:
                        true_or_value_kwargs['choices'] = arg.choices
                    true_or_value_kwargs['action'] = BoolOrAction
                    true_or_value_kwargs['nargs'] = '?'
                    true_or_value_kwargs['metavar'] = metavar
                    true_or_value_arg_names = options[:-1]
                    parser.add_argument(*true_or_value_arg_names, **true_or_value_kwargs)

                    # Allow --no-xyz
                    false_kwargs = kwargs.copy()
                    parser.add_argument(options[-1], action='store_false', **false_kwargs)
                elif arg.is_bool:
                    parser.add_argument(*options[:-1], action='store_true', **kwargs)
                    parser.add_argument(options[-1], action='store_false', **kwargs)
                elif arg.is_dict:
                    kwargs['action'] = DictAddAction
                    kwargs['metavar'] = metavar
                    parser.add_argument(*options, **kwargs)
                elif arg.is_list:
                    kwargs['action'] = ListAppendAction
                    kwargs['metavar'] = metavar
                    parser.add_argument(*options, **kwargs)
                else:
                    kwargs['type'] = arg.type
                    if arg.choices is not None:
                        kwargs['choices'] = arg.choices
                    kwargs['metavar'] = metavar
                    parser.add_argument(*options, **kwargs)

        return parser

    @property
    def help(self):
        help_ = self.get_arg_parser().format_help()
        help_ = help_.split(': ', 1)[1]
        help_ = help_.strip()
        return help_

    @property
    def usage(self):
        usage = self.get_arg_parser().format_usage()
        usage = usage.split(': ', 1)[1]
        usage = usage.strip()
        return usage

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return self.usage

    def __repr__(self):
        return 'Command(name={self.name})'.format(self=self)


command = Command.command


# Avoid circular import
from .config import Config, RawConfig, RunConfig  # noqa: E402
